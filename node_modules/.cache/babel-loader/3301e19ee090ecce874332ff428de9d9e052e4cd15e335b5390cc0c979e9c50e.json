{"ast":null,"code":"var _jsxFileName = \"/Users/alisaidmohamadou/Desktop/zombie-easter-egg/src/context/userContext.js\",\n  _s = $RefreshSig$();\nimport { createContext, useState, useEffect } from \"react\";\nimport { signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged } from \"firebase/auth\";\nimport { auth } from \"../firebase-config\";\nimport { doc, getDoc, setDoc, collection } from \"firebase/firestore\";\nimport { db } from \"../firebase-config\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const UserContext = /*#__PURE__*/createContext();\nconst UserContextProvider = props => {\n  _s();\n  const signUp = (email, pwd) => createUserWithEmailAndPassword(auth, email, pwd);\n  const signIn = (email, pwd) => signInWithEmailAndPassword(auth, email, pwd);\n  const [timeElapsed, setTimeElapsed] = useState({\n    minutes: 0,\n    seconds: 0\n  });\n  const [timerData, setTimerData] = useState({});\n\n  // Récupération des données du Timer à partir de Firebase en utilisant l'ID de l'utilisateur actuellement connecté\n\n  useEffect(() => {\n    const fetchTimerData = async () => {\n      const user = auth.currentUser;\n      if (user) {\n        const userId = user.email;\n        const userCollection = collection(db, userId);\n        const timerDoc = doc(userCollection, 'Timer');\n        const timerSnapshot = await getDoc(timerDoc);\n        if (timerSnapshot.exists()) {\n          setTimerData(timerSnapshot.data());\n        }\n      }\n    };\n    fetchTimerData();\n  }, []);\n  const [mapTimes, setMapTimes] = useState({\n    tranzit: {\n      minutes: 0,\n      seconds: 0\n    },\n    dierise: {\n      minutes: 0,\n      seconds: 0\n    },\n    mobofthedead: {\n      minutes: 0,\n      seconds: 0\n    },\n    buried: {\n      minutes: 0,\n      seconds: 0\n    },\n    origins: {\n      minutes: 0,\n      seconds: 0\n    }\n  });\n\n  // Utilisateur qui va se connecter\n  const [currentUser, setCurrentUser] = useState();\n  // Le temps d'avoir une réponse de Firebase\n  const [loadingData, setLoadingData] = useState(true);\n  const [modalState, setModalState] = useState({\n    signUpModal: false,\n    signInModal: false\n  });\n\n  // Permet de changer l'état d'authentification\n  useEffect(() => {\n    const unsubscribe = onAuthStateChanged(auth, currentUser => {\n      // Si je suis connecté alors ca renvoi le user sinon rien\n      setCurrentUser(currentUser);\n      setLoadingData(false);\n    });\n    return unsubscribe;\n  }, []);\n  const toggleModals = modal => {\n    if (modal === \"signIn\") {\n      setModalState({\n        signUpModal: false,\n        signInModal: true\n      });\n    }\n    if (modal === \"signUp\") {\n      setModalState({\n        signUpModal: true,\n        signInModal: false\n      });\n    }\n    if (modal === \"close\") {\n      setModalState({\n        signUpModal: false,\n        signInModal: false\n      });\n    }\n  };\n  const handleValidation = async (mapName, timeElapsed) => {\n    try {\n      const user = auth.currentUser;\n      if (user) {\n        const userId = user.email;\n\n        // Conversion du temps de l'application (minutes et secondes) en secondes\n        const totalSeconds = timeElapsed.minutes * 60 + timeElapsed.seconds;\n\n        // Met à jour la map correspondante dans la collection de l'utilisateur\n        const userCollection = collection(db, userId);\n        const timerDoc = doc(userCollection, \"Timer\");\n\n        // Récupère les valeurs actuelles du document \"Timer\"\n        const timerSnapshot = await getDoc(timerDoc);\n        const currentTimerData = timerSnapshot.data();\n\n        // Met à jour la map correspondante dans le document \"Timer\"\n        const updatedTimerData = {\n          ...currentTimerData,\n          [mapName]: totalSeconds\n        };\n        await setDoc(timerDoc, updatedTimerData);\n        console.log(\"Temps validé avec succès pour la map\", mapName);\n      } else {\n        // L'utilisateur n'est pas connecté ou auth.currentUser est null/indéfini\n        console.log(\"Utilisateur non connecté\");\n      }\n    } catch (error) {\n      console.error(\"Erreur lors de la validation du temps :\", error);\n    }\n  };\n  const handleSignIn = async (email, password) => {\n    try {\n      const {\n        user\n      } = await signInWithEmailAndPassword(auth, email, password);\n\n      // Utiliser l'adresse e-mail comme identifiant de l'utilisateur\n      const userId = user.email;\n\n      // Créer un document avec l'userId dans la collection \"users\"\n      await setDoc(doc(db, \"users\", userId), {\n        // Ajouter d'autres champs si nécessaire\n      });\n      console.log(\"Utilisateur connecté avec succès !\");\n    } catch (error) {\n      console.error(\"Erreur lors de la connexion de l'utilisateur :\", error);\n    }\n  };\n  const handleSignUp = async (email, password) => {\n    try {\n      const {\n        user\n      } = await createUserWithEmailAndPassword(auth, email, password);\n\n      // Utiliser l'adresse e-mail comme identifiant de l'utilisateur\n      const userId = user.email;\n\n      // Créer un document \"Timer\" dans la collection correspondant à l'userId\n      await setDoc(doc(db, userId, \"Timer\"), {\n        tranzit: 0,\n        dierise: 0,\n        mobofthedead: 0,\n        buried: 0,\n        origins: 0\n      });\n      console.log(\"Utilisateur connecté avec succès !\");\n    } catch (error) {\n      console.error(\"Erreur lors de la connexion de l'utilisateur :\", error);\n    }\n  };\n  return /*#__PURE__*/_jsxDEV(UserContext.Provider, {\n    value: {\n      modalState,\n      toggleModals,\n      signUp,\n      signIn,\n      currentUser,\n      loadingData,\n      timeElapsed,\n      setTimeElapsed,\n      handleValidation,\n      mapTimes,\n      setMapTimes,\n      handleSignIn,\n      handleSignUp\n    },\n    children: !loadingData && props.children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 176,\n    columnNumber: 5\n  }, this);\n};\n_s(UserContextProvider, \"2Gy2IRaEXzOkmwIkDGSu9PS9uzg=\");\n_c = UserContextProvider;\nexport default UserContextProvider;\nvar _c;\n$RefreshReg$(_c, \"UserContextProvider\");","map":{"version":3,"names":["createContext","useState","useEffect","signInWithEmailAndPassword","createUserWithEmailAndPassword","onAuthStateChanged","auth","doc","getDoc","setDoc","collection","db","jsxDEV","_jsxDEV","UserContext","UserContextProvider","props","_s","signUp","email","pwd","signIn","timeElapsed","setTimeElapsed","minutes","seconds","timerData","setTimerData","fetchTimerData","user","currentUser","userId","userCollection","timerDoc","timerSnapshot","exists","data","mapTimes","setMapTimes","tranzit","dierise","mobofthedead","buried","origins","setCurrentUser","loadingData","setLoadingData","modalState","setModalState","signUpModal","signInModal","unsubscribe","toggleModals","modal","handleValidation","mapName","totalSeconds","currentTimerData","updatedTimerData","console","log","error","handleSignIn","password","handleSignUp","Provider","value","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/alisaidmohamadou/Desktop/zombie-easter-egg/src/context/userContext.js"],"sourcesContent":["import { createContext, useState, useEffect } from \"react\";\nimport { signInWithEmailAndPassword, createUserWithEmailAndPassword, onAuthStateChanged } from \"firebase/auth\";\nimport { auth } from \"../firebase-config\"\nimport { doc, getDoc, setDoc, collection } from \"firebase/firestore\";\nimport { db } from \"../firebase-config\";\n\n\n\nexport const UserContext = createContext()\n\n\nconst UserContextProvider = (props) => {\n\n  const signUp = (email, pwd) => createUserWithEmailAndPassword(auth, email, pwd)\n  const signIn = (email, pwd) => signInWithEmailAndPassword(auth, email, pwd)\n\n  const [timeElapsed, setTimeElapsed] = useState({ minutes: 0, seconds: 0 });\n  const [timerData, setTimerData] = useState({});\n\n\n  // Récupération des données du Timer à partir de Firebase en utilisant l'ID de l'utilisateur actuellement connecté\n  \n  useEffect(() => {\n    const fetchTimerData = async () => {\n      const user = auth.currentUser;\n      if (user) {\n        const userId = user.email;\n        const userCollection = collection(db, userId);\n        const timerDoc = doc(userCollection, 'Timer');\n        const timerSnapshot = await getDoc(timerDoc);\n        if (timerSnapshot.exists()) {\n          setTimerData(timerSnapshot.data());\n         \n        }\n      }\n    };\n\n    fetchTimerData();\n  }, []);\n\n  \n\n  const [mapTimes, setMapTimes] = useState({\n    tranzit: { minutes: 0, seconds: 0 },\n    dierise: { minutes: 0, seconds: 0 },\n    mobofthedead: { minutes: 0, seconds: 0 },\n    buried: { minutes: 0, seconds: 0 },\n    origins: { minutes: 0, seconds: 0 }\n  });\n  \n  // Utilisateur qui va se connecter\n  const [currentUser, setCurrentUser] = useState();\n  // Le temps d'avoir une réponse de Firebase\n  const [loadingData, setLoadingData] = useState(true);\n\n\n  const [modalState, setModalState] = useState({ signUpModal: false, signInModal: false })\n\n  // Permet de changer l'état d'authentification\n  useEffect(() => {\n\n    const unsubscribe = onAuthStateChanged(auth, (currentUser) => {\n      // Si je suis connecté alors ca renvoi le user sinon rien\n      setCurrentUser(currentUser);\n      setLoadingData(false);\n    });\n    return unsubscribe;\n  }, []);\n\n\n  const toggleModals = modal => {\n    if (modal === \"signIn\") {\n      setModalState({\n        signUpModal: false,\n        signInModal: true\n      })\n    }\n\n    if (modal === \"signUp\") {\n      setModalState({\n        signUpModal: true,\n        signInModal: false\n      })\n    }\n\n    if (modal === \"close\") {\n      setModalState({\n        signUpModal: false,\n        signInModal: false\n      })\n    }\n  }\n\n  const handleValidation = async (mapName, timeElapsed) => {\n    try {\n      const user = auth.currentUser;\n      if (user) {\n        const userId = user.email;\n  \n        // Conversion du temps de l'application (minutes et secondes) en secondes\n        const totalSeconds = timeElapsed.minutes * 60 + timeElapsed.seconds;\n  \n        // Met à jour la map correspondante dans la collection de l'utilisateur\n        const userCollection = collection(db, userId);\n        const timerDoc = doc(userCollection, \"Timer\");\n  \n        // Récupère les valeurs actuelles du document \"Timer\"\n        const timerSnapshot = await getDoc(timerDoc);\n        const currentTimerData = timerSnapshot.data();\n  \n        // Met à jour la map correspondante dans le document \"Timer\"\n        const updatedTimerData = {\n          ...currentTimerData,\n          [mapName]: totalSeconds\n        };\n  \n        await setDoc(timerDoc, updatedTimerData);\n  \n  \n        console.log(\"Temps validé avec succès pour la map\", mapName);\n      } else {\n        // L'utilisateur n'est pas connecté ou auth.currentUser est null/indéfini\n        console.log(\"Utilisateur non connecté\");\n      }\n    } catch (error) {\n      console.error(\"Erreur lors de la validation du temps :\", error);\n    }\n  };\n  \n  \n\n  const handleSignIn = async (email, password) => {\n    try {\n      const { user } = await signInWithEmailAndPassword(auth, email, password);\n\n      // Utiliser l'adresse e-mail comme identifiant de l'utilisateur\n      const userId = user.email;\n\n      // Créer un document avec l'userId dans la collection \"users\"\n      await setDoc(doc(db, \"users\", userId), {\n        // Ajouter d'autres champs si nécessaire\n      });\n\n      console.log(\"Utilisateur connecté avec succès !\");\n    } catch (error) {\n      console.error(\"Erreur lors de la connexion de l'utilisateur :\", error);\n  }\n}\n\nconst handleSignUp = async (email, password) => {\n  try {\n    const { user } = await createUserWithEmailAndPassword(auth, email, password);\n\n    // Utiliser l'adresse e-mail comme identifiant de l'utilisateur\n    const userId = user.email;\n\n    // Créer un document \"Timer\" dans la collection correspondant à l'userId\n    await setDoc(doc(db, userId, \"Timer\"), {\n      tranzit:0,\n      dierise:0,  \n      mobofthedead:0,\n      buried:0,\n      origins:0,\n    });\n\n    console.log(\"Utilisateur connecté avec succès !\");\n  } catch (error) {\n    console.error(\"Erreur lors de la connexion de l'utilisateur :\", error);\n  }\n\n};\n  \n\n  return (\n\n    <UserContext.Provider value={{ modalState, toggleModals, signUp, signIn, currentUser, loadingData, timeElapsed, setTimeElapsed, handleValidation, mapTimes, setMapTimes, handleSignIn, handleSignUp,\n     }}>\n\n      {!loadingData && props.children}\n    </UserContext.Provider>\n  )\n}\n\nexport default UserContextProvider;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}